<?php

namespace App\Core\Providers;

use App\Core\ModuleManager;
use App\Core\Providers\AppServiceProvider;
use Illuminate\Support\Facades\Route;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Schema;
use Illuminate\Support\Facades\File;
use Illuminate\Support\ServiceProvider;

class ModuleServiceProvider extends ServiceProvider
{
    /**
     * Indicates if loading of the provider is deferred.
     *
     * @var bool
     */
    protected $defer = false;

    /**
     * Cache key for module providers manifest
     */
    protected const CACHE_KEY = 'module_providers_manifest';

    /**
     * Cache TTL (24 hours for production, 0 for development)
     */
    protected const CACHE_TTL = 86400;

    /**
     * Register services.
     */
    public function register(): void
    {
        // Register ModuleManager as singleton
        $this->app->singleton(ModuleManager::class);

        // Register AppServiceProvider
        $this->app->register(AppServiceProvider::class);

        // Defer module provider registration until after the framework has
        // fully booted so dependencies like the cache manager are available.
        $this->app->booted(function () {
        if (!$this->app->bound('module_providers_registered')) {
            $this->registerModuleProviders();
            $this->app->instance('module_providers_registered', true);
        }
        });
    }

    // /**
    //  * Bootstrap services.
    //  */
    public function boot(): void
    {
        $this->loadModuleRoutes();
        $this->registerModuleConfigs();
        $this->registerModuleViews();
        $this->registerModuleTranslations();
        $this->registerModuleMigrations();
    }

    /**
     * Get the services provided by the provider.
     *
     * @return array
     */
    public function provides()
    {
        return [ModuleManager::class];
    }

    /**
     * Register module service providers with caching
     */
    private function registerModuleProviders(): void
    {
        $moduleManager = $this->app->make(ModuleManager::class);

        // Get providers from cache or discover them
        $providersByModule = $this->getProvidersManifest($moduleManager);

        if (empty($providersByModule)) {
            return;
        }

        $totalProviders = 0;
        $shouldLog = config('app.debug', false) && config('logging.log_provider_discovery', false);

        foreach ($providersByModule as $moduleName => $providers) {
            if ($shouldLog) {
                \Illuminate\Support\Facades\Log::debug("Registering providers for module: {$moduleName}", [
                    'module' => $moduleName,
                    'count' => count($providers)
                ]);
            }

            foreach ($providers as $provider) {
                if (class_exists($provider)) {
                    try {
                        $this->app->register($provider);
                        $totalProviders++;

                        if ($shouldLog) {
                            \Illuminate\Support\Facades\Log::debug("Successfully registered provider: {$provider}", [
                                'module' => $moduleName,
                                'provider' => $provider
                            ]);
                        }
                    } catch (\Exception $e) {
                        \Illuminate\Support\Facades\Log::error("Failed to register provider: {$provider}", [
                            'module' => $moduleName,
                            'provider' => $provider,
                            'error' => $e->getMessage()
                        ]);
                    }
                }
            }
        }

        if ($shouldLog) {
            \Illuminate\Support\Facades\Log::info("Module service provider registration completed", [
                'total_providers_registered' => $totalProviders,
                'modules_processed' => count($providersByModule)
            ]);
        }
    }

    /**
     * Get providers manifest from cache or generate it
     */
    private function getProvidersManifest(ModuleManager $moduleManager): array
    {
        // Check for cached manifest file (generated by module:cache command)
        $cachedManifest = $this->getCachedManifest();
        if (!empty($cachedManifest)) {
            return $cachedManifest;
        }

        // Check config for manual manifest
        $configManifest = config('modules.manifest', []);
        if (!empty($configManifest) && !config('modules.auto_discovery', true)) {
            return $this->formatConfigManifest($configManifest);
        }

        // In production with cache enabled, use cache, but avoid using the
        // database cache driver before the "cache" table exists
        if (config('modules.cache_discovery', false)) {
            $defaultCacheStore = config('cache.default');
            $isDatabaseCache = $defaultCacheStore === 'database';
            $hasCacheTable = true;

            if ($isDatabaseCache) {
                try {
                    $hasCacheTable = Schema::hasTable('cache');
                } catch (\Throwable $e) {
                    $hasCacheTable = false;
                }
            }

            if (!$isDatabaseCache || ($isDatabaseCache && $hasCacheTable)) {
            $cacheTTL = config('modules.cache_ttl', self::CACHE_TTL);
            return Cache::remember(self::CACHE_KEY, $cacheTTL, function () use ($moduleManager) {
                return $this->discoverProviders($moduleManager);
            });
            }
        }

        // In development without caching, discover on each request
        return $this->discoverProviders($moduleManager);
    }

    /**
     * Get cached manifest from file
     */
    private function getCachedManifest(): array
    {
        $manifestPath = base_path('bootstrap/cache/modules.php');

        if (file_exists($manifestPath)) {
            return require $manifestPath;
        }

        return [];
    }

    /**
     * Format config manifest to match discovery format
     */
    private function formatConfigManifest(array $configManifest): array
    {
        $formatted = [];

        foreach ($configManifest as $moduleName => $config) {
            if (isset($config['providers']) && is_array($config['providers'])) {
                $formatted[$moduleName] = $config['providers'];
            }
        }

        return $formatted;
    }

    /**
     * Discover providers from modules
     */
    private function discoverProviders(ModuleManager $moduleManager): array
    {
        if (!$moduleManager->isModulesDiscovered()) {
            $moduleManager->discoverModules();
        }

        return $moduleManager->getServiceProvidersByModule();
    }

    /**
     * Load module routes
     */
    private function loadModuleRoutes(): void
    {
        $moduleManager = $this->app->make(ModuleManager::class);

        if (!$moduleManager->isModulesDiscovered()) {
            $moduleManager->discoverModules();
        }

        $modules = $moduleManager->getModules();

        foreach ($modules as $module) {
            $this->loadModuleRoutesForModule($module);
        }
    }

    /**
     * Load routes for a specific module
     */
    private function loadModuleRoutesForModule(array $module): void
    {
        $routesPath = $module['path'] . '/routes';

        if (file_exists($routesPath . '/api.php')) {
            // Load API routes with /api/v1 prefix
            Route::prefix('api/v1')->group(function () use ($routesPath) {
                $this->loadRoutesFrom($routesPath . '/api.php');
            });
        }

        if (file_exists($routesPath . '/web.php')) {
            $this->loadRoutesFrom($routesPath . '/web.php');
        }
    }

    /**
     * Register module configs with Laravel's config system
     */
    private function registerModuleConfigs(): void
    {
        $moduleManager = $this->app->make(ModuleManager::class);

        if (!$moduleManager->isModulesDiscovered()) {
            $moduleManager->discoverModules();
        }

        $modules = $moduleManager->getModules();

        foreach ($modules as $moduleName => $module) {
            if (!empty($module['config'])) {
                // Register with multiple access patterns
                $this->app['config']->set($moduleName, $module['config']);
                $this->app['config']->set("modules.{$moduleName}", $module['config']);
            }
        }
    }

    /**
     * Clear the module providers cache
     */
    public function clearCache(): void
    {
        Cache::forget(self::CACHE_KEY);
    }


    // Add:
    private function registerModuleViews(): void
    {
        $mm = $this->app->make(\App\Core\ModuleManager::class);
        if (!$mm->isModulesDiscovered()) $mm->discoverModules();

        foreach ($mm->getModules() as $module) {
            $viewsPath = $module['path'] . '/resources/views';
            if (is_dir($viewsPath)) {
                $this->loadViewsFrom($viewsPath, strtolower($module['name']));
            }
        }
    }

    private function registerModuleTranslations(): void
    {
        $mm = $this->app->make(\App\Core\ModuleManager::class);
        if (!$mm->isModulesDiscovered()) $mm->discoverModules();

        foreach ($mm->getModules() as $module) {
            $langPath = $module['path'] . '/resources/lang';
            if (is_dir($langPath)) {
                $this->loadTranslationsFrom($langPath, strtolower($module['name']));
            }
        }
    }

    private function registerModuleMigrations(): void
    {
        $mm = $this->app->make(\App\Core\ModuleManager::class);
        if (!$mm->isModulesDiscovered()) $mm->discoverModules();

        foreach ($mm->getModules() as $module) {
            // Support both common casings
            $paths = [
                $module['path'] . '/Database/Migrations',
                $module['path'] . '/database/migrations',
            ];

            foreach ($paths as $migrationPath) {
                if (is_dir($migrationPath)) {
                    $this->loadMigrationsFrom($migrationPath);
                }
            }
        }
    }

}
